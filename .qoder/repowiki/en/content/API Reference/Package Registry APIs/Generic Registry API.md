# Generic Registry API

<cite>
**Referenced Files in This Document**   
- [package.go](file://models/packages/package.go)
- [package_version.go](file://models/packages/package_version.go)
- [package_file.go](file://models/packages/package_file.go)
- [descriptor.go](file://models/packages/descriptor.go)
- [package.go](file://routers/api/v1/packages/package.go)
- [content_store.go](file://modules/packages/content_store.go)
- [api_packages_test.go](file://tests/integration/api_packages_test.go)
</cite>

## Table of Contents
1. [Introduction](#introduction)
2. [URL Structure](#url-structure)
3. [Authentication](#authentication)
4. [Package Management Endpoints](#package-management-endpoints)
5. [Versioning Scheme](#versioning-scheme)
6. [File Upload and Download](#file-upload-and-download)
7. [Examples](#examples)
8. [Common Issues](#common-issues)
9. [Performance Considerations](#performance-considerations)

## Introduction
The Generic Registry API in Gitea provides a simple HTTP-based interface for uploading and downloading arbitrary files with versioning support. This API enables users to store generic binary artifacts, configuration files, or any other content in a structured manner within Gitea's package management system. The registry supports both user and organization owners, with comprehensive access control through API tokens and deploy tokens.

The Generic Registry is designed to be straightforward and flexible, allowing for semantic versioning or custom version strings. It integrates seamlessly with Gitea's existing authentication and authorization mechanisms, ensuring secure access to packages. The API follows RESTful principles with predictable URL structures and standard HTTP response codes.

**Section sources**
- [package.go](file://models/packages/package.go#L1-L352)
- [package_version.go](file://models/packages/package_version.go#L1-L351)

## URL Structure
The Generic Registry API uses a hierarchical URL structure that includes the owner, package type, package name, version, and filename. This structure provides a clear and consistent way to access packages and their contents.

The base URL pattern is:
```
/api/packages/{owner}/{type}/{name}/{version}/{filename}
```

Where:
- `{owner}`: The username or organization name that owns the package
- `{type}`: The package type, which must be "generic" for generic packages
- `{name}`: The name of the package
- `{version}`: The version string for the package
- `{filename}`: The name of the specific file within the package

For example, to access version 1.0.3 of a package named "test-package" owned by user "john" with a file named "app.bin", the URL would be:
```
/api/packages/john/generic/test-package/1.0.3/app.bin
```

Additional endpoints for package management follow a similar pattern:
- List packages: `/api/v1/packages/{owner}`
- Get specific package: `/api/v1/packages/{owner}/{type}/{name}/{version}`
- List package versions: `/api/v1/packages/{owner}/{type}/{name}`
- Get latest version: `/api/v1/packages/{owner}/{type}/{name}/-/latest`

**Section sources**
- [package.go](file://routers/api/v1/packages/package.go#L1-L457)
- [package.go](file://models/packages/package.go#L1-L352)

## Authentication
All operations on the Generic Registry require authentication, with both read and write operations protected by API tokens or deploy tokens. This ensures that only authorized users can access or modify packages.

### API Tokens
API tokens can be generated by users through the Gitea web interface or API. These tokens provide full access to the user's packages and can be used for both uploading and downloading operations.

To use an API token, include it in the Authorization header:
```
Authorization: token YOUR_API_TOKEN
```

Or as a URL parameter:
```
?token=YOUR_API_TOKEN
```

### Deploy Tokens
Deploy tokens are specifically designed for deployment scenarios and can be configured with read-only access. They are ideal for continuous integration/continuous deployment (CI/CD) pipelines where packages need to be downloaded but not modified.

Deploy tokens can be created at the repository or organization level and scoped to specific package types. For the Generic Registry, ensure the deploy token has the "read:packages" or "write:packages" scope as needed.

### Token Scopes
- `read:packages`: Allows downloading packages and viewing package metadata
- `write:packages`: Allows uploading new packages and versions, in addition to read access
- `delete:packages`: Allows deleting packages and versions

Authentication failures result in HTTP 401 (Unauthorized) or HTTP 403 (Forbidden) responses, depending on whether the token is invalid or lacks sufficient permissions.

**Section sources**
- [package.go](file://routers/api/v1/packages/package.go#L1-L457)
- [auth.go](file://models/auth/access_token.go#L1-L50)

## Package Management Endpoints
The Generic Registry API provides several endpoints for managing packages, versions, and associated metadata.

### List Packages
Retrieve all packages owned by a specific user or organization.

**Endpoint**: `GET /api/v1/packages/{owner}`

**Parameters**:
- `type`: Filter by package type (e.g., "generic")
- `q`: Filter by package name
- `page`: Page number for pagination
- `limit`: Number of results per page

**Response**: Returns a JSON array of package objects with metadata including name, version, type, and creator.

### Get Package
Retrieve metadata for a specific package version.

**Endpoint**: `GET /api/v1/packages/{owner}/{type}/{name}/{version}`

**Response**: Returns a JSON object with detailed information about the package version, including creation timestamp, download count, and associated files.

### Delete Package
Remove a specific package version.

**Endpoint**: `DELETE /api/v1/packages/{owner}/{type}/{name}/{version}`

**Response**: HTTP 204 No Content on success, or appropriate error code.

### List Package Versions
Retrieve all versions of a specific package.

**Endpoint**: `GET /api/v1/packages/{owner}/{type}/{name}`

**Parameters**:
- `page`: Page number for pagination
- `limit`: Number of results per page

**Response**: Returns a JSON array of package version objects, sorted by creation date (newest first).

### Get Latest Package Version
Retrieve the most recent version of a package.

**Endpoint**: `GET /api/v1/packages/{owner}/{type}/{name}/-/latest`

**Response**: Returns a JSON object with information about the latest package version.

### Link Package to Repository
Associate a package with a repository for better organization and access control.

**Endpoint**: `POST /api/v1/packages/{owner}/{type}/{name}/-/link/{repo_name}`

**Response**: HTTP 201 Created on success.

### Unlink Package from Repository
Remove the association between a package and a repository.

**Endpoint**: `POST /api/v1/packages/{owner}/{type}/{name}/-/unlink`

**Response**: HTTP 204 No Content on success.

**Section sources**
- [package.go](file://routers/api/v1/packages/package.go#L1-L457)
- [package_version.go](file://models/packages/package_version.go#L1-L351)

## Versioning Scheme
The Generic Registry supports flexible versioning schemes, accommodating both semantic versioning and custom version strings.

### Semantic Versioning
The API fully supports semantic versioning (SemVer) with the format MAJOR.MINOR.PATCH (e.g., 1.2.3). Pre-release versions are also supported using the standard SemVer syntax (e.g., 1.2.3-alpha, 1.2.3-beta.1).

Packages marked as semver-compatible will have their version strings validated according to SemVer rules. The API can sort and compare semver-compatible versions appropriately, ensuring that the latest stable version is correctly identified.

### Custom Version Strings
For projects that don't follow semantic versioning, the Generic Registry accepts any valid string as a version identifier. This includes:
- Date-based versions (e.g., 2023.01.15, 23.1.15)
- Build numbers (e.g., build-1234, release-2023-Q1)
- Simple incrementing numbers (e.g., 1, 2, 3)
- Custom labels (e.g., stable, beta, nightly)

### Version Comparison
When determining the "latest" version:
1. For semver-compatible packages: Versions are compared according to SemVer rules
2. For non-semver packages: Versions are sorted by creation timestamp (newest first)

The API prevents uploading multiple files with the same owner, package name, version, and filename combination, ensuring version integrity.

**Section sources**
- [package_version.go](file://models/packages/package_version.go#L1-L351)
- [descriptor.go](file://models/packages/descriptor.go#L1-L281)

## File Upload and Download
The Generic Registry API provides straightforward mechanisms for uploading and downloading package files.

### Uploading Files
To upload a file to the Generic Registry, use an HTTP PUT request to the package URL.

**Endpoint**: `PUT /api/packages/{owner}/generic/{name}/{version}/{filename}`

**Headers**:
- `Authorization: token YOUR_TOKEN`
- `Content-Type: application/octet-stream` (or appropriate MIME type)

**Body**: The binary content of the file to upload

**Response**: HTTP 201 Created on success, with location header pointing to the uploaded file.

The upload process:
1. Client sends PUT request with file content
2. Server calculates SHA-256 hash of the content
3. Content is stored in the configured storage backend (local filesystem, S3, etc.)
4. Package metadata is updated in the database
5. Response is sent back to the client

### Downloading Files
To download a file from the Generic Registry, use an HTTP GET request to the package URL.

**Endpoint**: `GET /api/packages/{owner}/generic/{name}/{version}/{filename}`

**Headers**:
- `Authorization: token YOUR_TOKEN` (if required)

**Response**: The file content with appropriate Content-Type and Content-Disposition headers.

### Range Requests
The API supports HTTP range requests for partial content retrieval, which is particularly useful for:
- Resuming interrupted downloads
- Streaming large files
- Downloading specific portions of large binaries

To make a range request:
```
GET /api/packages/owner/generic/name/version/filename
Range: bytes=0-1023
```

The server will respond with HTTP 206 Partial Content and the requested byte range.

### Content Storage
Package files are stored in a content-addressable storage system using SHA-256 hashes as identifiers. This enables:
- Deduplication of identical files across different packages
- Integrity verification through hash checking
- Efficient storage management

The physical storage location follows a hierarchical pattern: `{first_2_chars}/{next_2_chars}/{full_sha256_hash}`

**Section sources**
- [content_store.go](file://modules/packages/content_store.go#L1-L75)
- [package_file.go](file://models/packages/package_file.go#L1-L243)
- [package.go](file://routers/api/v1/packages/package.go#L1-L457)

## Examples
This section provides practical examples of using the Generic Registry API with common HTTP clients.

### Uploading a Package with curl
```bash
# Upload a binary file to the Generic Registry
curl -X PUT \
  -H "Authorization: token YOUR_API_TOKEN" \
  -H "Content-Type: application/octet-stream" \
  --data-binary @./myapp-v1.0.0-linux-amd64 \
  https://gitea.example.com/api/packages/username/generic/myapp/1.0.0/myapp-v1.0.0-linux-amd64
```

### Uploading with authentication via URL parameter
```bash
# Alternative authentication method using token parameter
curl -X PUT \
  -H "Content-Type: application/octet-stream" \
  --data-binary @./config-v2.1.json \
  https://gitea.example.com/api/packages/orgname/generic/config/2.1/config.json?token=YOUR_DEPLOY_TOKEN
```

### Downloading a Package
```bash
# Download a package file
curl -H "Authorization: token YOUR_API_TOKEN" \
  -o myapp-latest \
  https://gitea.example.com/api/packages/username/generic/myapp/latest/myapp
```

### Download with range request
```bash
# Download first 1MB of a large file
curl -H "Authorization: token YOUR_API_TOKEN" \
  -H "Range: bytes=0-1048575" \
  -o myapp-part1 \
  https://gitea.example.com/api/packages/username/generic/myapp/1.0.0/large-dataset.bin
```

### Listing Package Versions
```bash
# Get all versions of a package
curl -H "Authorization: token YOUR_API_TOKEN" \
  https://gitea.example.com/api/v1/packages/username/generic/myapp
```

### Getting the Latest Version
```bash
# Get metadata for the latest version
curl -H "Authorization: token YOUR_API_TOKEN" \
  https://gitea.example.com/api/v1/packages/username/generic/myapp/-/latest
```

### Using in CI/CD Pipeline
```yaml
# Example GitHub Actions workflow using Gitea Generic Registry
jobs:
  deploy:
    runs-on: ubuntu-latest
    steps:
      - name: Upload artifact
        run: |
          curl -X PUT \
            -H "Authorization: token ${{ secrets.GITEA_TOKEN }}" \
            -H "Content-Type: application/gzip" \
            --data-binary @dist/app-${{ github.sha }}.tar.gz \
            ${{ env.GITEA_URL }}/api/packages/${{ github.repository_owner }}/generic/app/${{ github.sha }}/app.tar.gz
```

**Section sources**
- [api_packages_test.go](file://tests/integration/api_packages_test.go#L39-L119)
- [package.go](file://routers/api/v1/packages/package.go#L1-L457)

## Common Issues
This section addresses frequently encountered issues when working with the Generic Registry API.

### Authentication Failures
**Symptoms**: HTTP 401 Unauthorized or HTTP 403 Forbidden responses during upload operations.

**Causes and Solutions**:
- **Invalid token**: Verify the token is correct and hasn't been revoked
- **Insufficient scope**: Ensure the token has "write:packages" scope for uploads
- **Token expiration**: Generate a new token if the current one has expired
- **Incorrect header format**: Use `Authorization: token YOUR_TOKEN` or `?token=YOUR_TOKEN`

### Version Conflicts
**Symptoms**: HTTP 409 Conflict when attempting to upload a package.

**Causes and Solutions**:
- **Existing version**: The same version already exists; either delete the existing version first or use a new version string
- **Semantic versioning conflicts**: For semver-compatible packages, ensure the version string follows SemVer rules
- **Case sensitivity**: Package names and versions are case-sensitive; ensure consistency in naming

### Filename Encoding Issues
**Symptoms**: Files with special characters in the filename cannot be uploaded or downloaded.

**Causes and Solutions**:
- **URL encoding**: Special characters in filenames must be properly URL-encoded
- **Reserved characters**: Avoid using characters that have special meaning in URLs (?, #, %, etc.)
- **Length limitations**: Very long filenames may exceed URL length limits; consider shortening or using hashes

### Large File Uploads
**Symptoms**: Timeouts or connection resets when uploading large files.

**Causes and Solutions**:
- **Server timeout**: Increase client-side timeout settings
- **Network instability**: Implement retry logic with exponential backoff
- **Storage limitations**: Verify sufficient disk space is available on the server

### Rate Limiting
**Symptoms**: HTTP 429 Too Many Requests responses.

**Causes and Solutions**:
- **Excessive requests**: Implement proper rate limiting in client applications
- **Burst uploads**: Space out upload operations over time
- **Configuration**: Check server rate limiting settings if you have administrative access

**Section sources**
- [package.go](file://routers/api/v1/packages/package.go#L1-L457)
- [package_version.go](file://models/packages/package_version.go#L1-L351)

## Performance Considerations
Optimizing performance is crucial when working with the Generic Registry, especially for large binary files and high-frequency operations.

### Handling Large Binary Files
For large files, consider the following best practices:

**Chunked Uploads**: While the API doesn't natively support chunked uploads, implement client-side chunking:
- Split large files into smaller chunks (e.g., 100MB each)
- Upload chunks sequentially or in parallel
- Use a manifest file to track uploaded chunks

**Resumable Uploads**: Implement upload resumption:
- Track upload progress locally
- On failure, resume from the last successfully uploaded byte
- Use ETags or custom headers to verify upload state

### Optimizing Download Speeds
**Range Requests**: Utilize HTTP range requests for:
- Parallel downloads of different file segments
- Resuming interrupted downloads
- Streaming large files without loading them entirely into memory

**CDN Integration**: For high-traffic packages, consider:
- Configuring a CDN in front of Gitea
- Using signed URLs for secure CDN access
- Setting appropriate cache headers (Cache-Control, Expires)

### Storage Backend Optimization
The performance of the Generic Registry depends heavily on the underlying storage backend:

**Local Storage**: For small to medium deployments:
- Use fast SSD storage
- Ensure adequate I/O capacity
- Regularly monitor disk space usage

**Object Storage (S3, MinIO, etc.)**: For scalable deployments:
- Enable server-side encryption
- Configure appropriate storage classes (standard, infrequent access)
- Use transfer acceleration when available

**Caching**: Implement caching strategies:
- Cache frequently accessed package metadata
- Use HTTP caching headers (ETag, Last-Modified)
- Consider a reverse proxy with caching capabilities

### Database Performance
The registry's database performance can impact overall API responsiveness:

**Indexing**: Ensure proper indexes on:
- Package name and version combinations
- Creation timestamps for sorting
- Owner and repository references

**Connection Pooling**: Configure appropriate database connection pooling to handle concurrent requests.

**Section sources**
- [content_store.go](file://modules/packages/content_store.go#L1-L75)
- [package_file.go](file://models/packages/package_file.go#L1-L243)
- [setting.go](file://modules/setting/packages.go#L1-L50)